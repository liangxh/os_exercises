#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。

> 1) UEFI使操作系统可以自动从预启动的操作环境中加载到一种操作系统上,　相比BIOS需要从硬盘多次读取扇区来加载操作系统要快得多;　
2) UEFI对引导记录的可信性进行检查,　只有通过检查的引导记录才会被读进去并赋予控制权,　减少了安全的风险;
3) UEFI本身具备文件系统的支持,　可直接读取FAT分区.
 
 2. 描述PXE的大致启动流程。

> 1) 通过UDP协议发送受限广播(255.255.255.255),目标端口67, 是DHCP命令中的DHCP discover,带PXEClient标志,并在UDP 68端口监听。
2) DHCP服务器在67端口收到请求后,通过UDP协议发送受限广播(255.255.255.255)，目标端口68,是DHCP命令中的DHCP offer,附带客户端ip,网关,tftp服务器ip, 子网掩码, 可引导的文件名等.
3) 客户机在68端口收到服务器回复的信息,客户机配置自身ip，从此时起，客户机可以使用单播通讯了。
4) 客户端通过tftp协议发送获取引导文件的命令,并将获取的引导文件存放在地址 0:7c00 （第3步中获取的引导文件名）.
5) 跳转到0:7c00开始执行引导文件中的代码,从此时起cpu控制权己交给引导文件.

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。

> NTLDR(全称NT Loader)是系统加载程序, 其文件是Windows NT/windows 2000/windows XP/windows server 2003的引导文件, 整个启动过程如下:
1) 电源自检程序开始运行;
2) 主引导记录被装入内存，并且程序开始执行;
3) 活动分区的引导扇区被装入内存;
4)　NTLDR从引导扇区被装入并初始化;
5) 将处理器的实模式改为32位平滑内存模式;
6) NTLDR开始运行在NTLDR内部的小文件系统驱动程序(用于读FAT或NTFS);
7) NTLDR读boot.ini文件;
8) NTLDR装载所选操作系统;
如果windows NT/windows 2000/windows XP/windows server 2003这些操作系统被选择，NTLDR运行Ntdetect。
对于其他的操作系统，NTLDR装载并运行Bootsect.dos然后向它传递控制。
windows NT过程结束。
9) Ntdetect搜索计算机硬件并将列表传送给NTLDR，以便将这些信息写进\\HKE Y_LOCAL_MACHINE\HARDWARE中;
10) 然后NTLDR装载Ntoskrnl.exe，Hal.dll和系统信息集合;
11) Ntldr搜索系统信息集合，并装载设备驱动配置以便设备在启动时开始工作;
12) Ntldr把控制权交给Ntoskrnl.exe，这时,启动程序结束,装载阶段开始.
 
 2. 了解GRUB的启动流程。

> Grub的代码分成两部分,　一部分在第一扇区的主引导记录MBR中,　另一部分则在磁盘的某个位置中.
在计算机启动,　BIOS完成启动自检后
1) 读取MBR然后跳转至Grub的第一部分代码,　其中提供了第二部分代码的信息;
2) 跳转至Grub的第二部分代码,　此为核心部分,　负责读取/boot/grub/grub.conf文件;
3) 根据grub.conf显示操作系统的菜单,　提供用户交互界面;
4) 根据用户的选择把控制权交给内核程序, 由内核程序启动操作系统.
 
 3. 比较NTLDR和GRUB的功能有差异。

> NTLDR的设计只供引导windows系统, 且只能引导在硬盘上的操作系统；
GRUB属于第三方操作系统引导器, 一方面支持不同的操作系统包括windows, linux, dos, 另一方面可以引导硬盘, 光盘, 网络上的操作系统, 灵活性要比NTLDR强.
 
 4. 了解u-boot的功能。

 > U-Boot用於加載內核, 它的啟動過程可分為兩個階段, 負責功能如下:
第一階段
1) 硬件設備的初始化, 包括串口, I/O設備等; 
2) 加載U-Boot第二階段代碼到內存空間; 
3) 設置棧; 
4) 跳转至第二階段代碼的入口; 
第二階段
1) 初始化本階段使用的硬件設備; 
2) 檢查系统內存映射; 
3) 將內核從閃存讀取至內存中; 
4) 為內核設置啟動參數; 
5) 調用內核.

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
